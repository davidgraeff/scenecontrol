{"name":"Scenecontrol","tagline":"A plugin extendable software for home automation / domotics requiering a small always-on pc like the raspberry pi. Use your modern webbrowser to simply configure events-conditions-actions correlations. Easily extendable functionality through a true plugin architecture.","body":"Heimautomatisierungssoftware:\r\n=============================\r\nEine Plugin orientierte Steuersoftware für die Heimautomatisierung. Einige auf die Bedürfnisse\r\nder Entwickler abgestimmten Plugins sowie generische Plugins sind bereits vorhanden.\r\nDiese README gibt erste Hintergrundinformationen.\r\n\r\n[![Build Status](https://travis-ci.org/davidgraeff/scenecontrol.png?branch=master)](https://travis-ci.org/davidgraeff/scenecontrol)\r\n\r\nArchitektur:\r\n============\r\nKernprozess:\r\n------------\r\nDer ausführende Kernprozess wird im weiteren SceneServer genannt.\r\nDer SceneServer baut nach dem Start eine Verbindung zur Datenhaltung auf und fordert alle Plugin Konfigurationen an.\r\nEine Plugin Konfiguration enthält die benötigten Parameter um eine bestimmte Plugin Instanz\r\nerfolgreich starten zu können. Es können also jederzeit mehrfache Instanzen eines Plugins gestartet werden.\r\nPlugin Instanzen laufen in eigenen Prozessen und können untereinander oder mit dem SceneServer kommunizieren.\r\n\r\nSobald ein Pluginprozess angelaufen und eine Verbindung zum Server hergestellt worden ist, werden aus der Datenhaltung\r\nalle auf diese Plugin Instanz registrierten Ereignisse angefordert and an die Plugin Instanz weitergereicht.\r\n\r\nSobald ein Ereignis entsprechend der Ereignisdaten eintritt, wird der SceneServer informiert und lädt aus der Datenhaltung\r\ndie mit dem Ereignisdaten verbundenen Profile und damit wiederum verbundene Bedingungsdaten und Aktionsdaten.\r\n\r\nWenn alle betroffenen Plugin Instanzen die Bedingungen anhand der Bedinungsdaten mit positiver Rückmeldung\r\nevaluiert haben, werden die Aktionsdaten an die zuständigen Plugin Instanzen zur Ausführung gesendet.\r\n\r\nÜber einen TCP Port i.d.R. Port 3101 können per JSON kodierte Nachrichten an den Prozess abgesetzt werden.\r\nDer Server selber bietet keine Session/Sicherheitsverwaltung an und bietet außer direkter Sockets keine andere\r\nKontrollmöglichkeit an. Diese Funktionalitäten können mit zusätzlichen Proxy Prozessen abgedeckt werden.\r\n\r\nDurch die Trennung in Prozesse mit fest gelegtem, eingegrenztem Aufgabenbereich ist die Ausfallsicherheit der\r\ngesamten Architektur besonders hoch und für den 24/7 Betrieb ausgelegt.\r\n\r\nWebsocketsproxy:\r\n----------------\r\nÜber den Websocketsproxy können sich über https Webclients über das WebSocket Protokoll mit dem SceneServer verbinden\r\nund das JSON Kommandointerface des SceneServers nutzen.\r\n\r\nSessionProxy:\r\n-------------\r\nDer SessionProxy handelt mit dem SceneServer einen neuen Port für das JSON Kommandointerface aus und öffnet selber\r\nden JSON Kommandointerface Port. Somit werden effektiv alle neuen Verbindungen über den SessionProxy ablaufen.\r\nAlle Verbindungen erfordern ab dann eine Authentifizierung gegenüber den auf dem Betriebssystem vorhandenen Benutzern.\r\nZugriffsrechte werden durch Gruppenmitgliedschaften des angegeben Benutzers geregelt und müssen in der SessionProxy\r\nKonfiguration gesondert angegeben werden.\r\nEin Beispiel: Ein Nutzer wählt über die Android App eine Szene zur Ausführung aus.\r\nDer SessionProxy wird diese Ausführungsanfrage nur an den SceneServer weiterleiten, wenn der Nutzer sich als \"abc\"\r\nbeim Start der Android App authorisiert hat.\r\n\r\nPlugin und Plugin<->SceneServer Kommunikation:\r\n----------------------------------------------\r\nPlugins sind als eigene Prozesse modelliert, welche selbstständig eine Kommunikationsverbindung zum Server aufbauen müssen.\r\nDa viele Qt Container und Basisklassen serialisiert werden können, wird ein einfaches QDataStream basiertes Protokoll für\r\ndie Kommunikation zwischen Plugin Prozess und SceneServer verwendet. Unter Windows werden NamedPipes, unter Linux/MacOS\r\nUnixSockets verwendet.\r\nPlugins können Eigenschaften (properties) besitzen und auf Eigenschaftsänderungen des Servers oder anderer Plugins\r\nreagieren.\r\nEin Plugin muss ein C++/Qt PluginInterface implementieren. Entsprechend markierte Funktionen dienen als Ereignis, Bedingungs- oder\r\nAktionsmethoden und können vom SceneServer direkt genutzt werden.\r\n\r\nDatenspeicherung:\r\n-----------------\r\nEreignisse, Bedingungen, Aktionen und Szenen werden als JSON Objekte direkt auf dem Dateisystem hinterlegt. Die\r\nDatenspeicherung ist jedoch durch eine eigene Bibliothek gekapselt um weitere Datenspeicherungssysteme leichter\r\nnutzbar zu machen. Die Speicherung auf dem Dateisystem bietet jedoch bereits das Erfassen von Änderungen der Daten durch\r\nDrittanwendungen sowie die Nutzung üblicher Dateiverwaltungswerkzeuge. Manuelles Replizieren sowie\r\nregelmäßige Sicherungen können auf Dateiebene genutzt werden (Dropbox, github, ...).\r\n\r\nSzenen:\r\n-------\r\nEine Szene definiert sich durch einen Namen, gfs. zugewiesene Kategorien und Szenenelementen.\r\nSzenenelemente sind Ereignisse, Bedingungen und Aktionen, welche als gerichteter Graph organisiert sind.\r\nEin Graph enthält Knoten und Kanten, welche die Knoten verbinden. Übertragen auf eine Szene\r\nsind dadurch i.d.R. Ereignisse über Kanten mit Bedingungen verknüpft, welche wiederum mit\r\nAktionen verbunden sind. Eine solche Kette von Szenenelementen heißt hier Ereigniskette.\r\nEine Szene kann mehrere Ereignisketten enthalten.\r\n\r\nEin Beispiel: Ein Ereignis kann das Eintreten eines gewissen Zeitpunktes sein,\r\neine daran angebundene Bedingung könnte einen Steckdosenzustand prüfen,\r\neine darauf folgende Aktion löst etwa das Ändern der Lichwerte von Leuchtdioden aus.\r\n\r\nAnwendungsgebiete:\r\n==================\r\n1. Intelligenter Wecker\r\n2. Energiesparsystem\r\n3. Intelligenter Raum\r\n4. Automatisiertes Heimkino\r\n\r\nGrafisches Programm zur Verwaltung von Szenen:\r\n==============================================\r\nUm Ereignisse, Bedingungen und Aktionen in Szenen grafisch zu gestalten befindet\r\nsich eine HTML5/JS Browser Anwendung im Ordner \"htmleditor\".\r\nDer SceneServer und der WebSocketProxy müssen laufen.\r\n\r\nMitgelieferte Plugins:\r\n======================\r\nGenerische Plugins:\r\n-------------------\r\n* Leds: Generisches Leuchtdioden Plugin zur Verwaltung aller angemeldeten Leuchtdioden\r\n* DMX/ArtNet: Erlaubt die Steuerung von konfigurierten DMX Lampen über das Leds Plugin. Verwendet ArtNet, also ist eine Hardware Umsetzung IP-->DMX notwendig.\r\n* Switches: Generisches Steckdosen Plugin zur Verwaltung aller angemeldeten Steckdosen\r\n* Modes: Bietet eine frei änderbare Variable an um den Modus des Servers (etwa Musiksteuerung, Videosteuerung) zu markieren.\r\n* Time: Bietet feste und periodische Zeitereignisse an.\r\n* WOL: Wakeup on lan. Ermöglicht das starten eines über die angegebene MAC festgelegten PCs, sofern die Zielnetzwerkkarte dies unterstützt.\r\n\r\nGenerisches Plugins (Betriebssystemabhängig):\r\n---------------------------------------------\r\n* Linux Input Events (linux only): Tastenereignisse vom Linux Input Framework (etwa usb Fernbedienungen, Tastaturen).\r\n\r\nSoftwareabhängige Plugins:\r\n--------------------------\r\n* MPD: Steuert den Music Player Daemon.\r\n* XBMC: Steuert das XBox Media Center.\r\n* Pulseaudio (linux only): Steuert Lautstärkekanäle des Pulseaudio daemons.\r\n\r\nHardwareabhängige Plugins (in eigenem Repository):\r\n--------------------------------------------------\r\n* Anel sockets: Steuert Steckdosenleisten von der Firma anel (http://www.anel-elektronik.de/).\r\n* Projector Sanyo Z700: Steuert den Sanyo Projector Z700 über das serielle Interface.\r\n\r\nPlugins für mitgelieferte Tools:\r\n--------------------------------\r\n* RemoteSystem: Ermöglicht Steuerbefehle an alle Windows Computer im selben Subnetzwerk,\r\n  welche die mitgelieferte Clientsoftware gestartet haben, abzusetzen.\r\n  Zugehöriges Projekt: https://github.com/davidgraeff/windows_net_control\r\n\r\nFertige Binaries:\r\n=================\r\n* Ubuntu 12.04, 12.10, 13.04 (x86, x64, ARM_Hf): https://launchpad.net/~david-graeff/+archive/scenecontrol\r\n\r\nSoftware bauen:\r\n===============\r\nEs wird CMake (www.cmake.org) benötigt. Im CMake-Gui Programm kann grafisch\r\nder Quellcodeordner und ein davon unabhängiger BUILD-Ordner angegeben werden.\r\nCMake versucht alle benötigten Abhängigkeiten und den angegebenen C++ Compiler\r\nzu finden. Im nachfolgendem Abschnitt sind die Abhängigkeiten noch einmal\r\naufgeführt. Nach dem Generierungsschritt liegen (je nach Auswahl) Visual Studio\r\nProjektdateien, Makefiles, usw vor.\r\n\r\nUnter Windows: Hier wird VisualStudio 10+ empfohlen. Auf der Konsole kann nmake\r\nverwendet werden, ansonsten lässt sich das Projekt auch mit der VS IDE bauen.\r\n\r\nUnter Linux: Hier bietet sich das Erstellen lassen von Makefiles an. Anschließend\r\nin den BUILD-Ordner wechseln und den Befehl \"make\" ausführen. Um ein Deb Packet\r\ngenerieren zu lassen den Befehl \"make package\" nutzen.\r\n\r\nAbhängigkeiten:\r\n---------------\r\n| Name        | Ubuntu Paket           | Beschreibung  | Komponenten\r\n| ------------- |:-------------:| -----:| -----|\r\n| Qt4      | libqt4-dev | Qt4 Framework | Kernprozess\r\n| SSL      | libssl-dev | Sichere Verbindung | Kernprozess, Kontrollsocket\r\n| PAM      | libpam0g-dev      |   Benutzerauthentifizierung | SessionProxy\r\n| Pulseaudio | libpulse-dev      |    Pulseaudio | Plugin: Pulseaudio\r\n| UDEV | libudev-dev      |    Linux Input Events | Plugin: Linux_input_events\r\n\r\nWeiterentwicklung:\r\n------------------\r\n| Zeitraum        | Komponente        | Beschreibung\r\n| ------------- |-------------| -----|\r\n| 1. Quartal 2013 |  Plugin: dmx/artnet | libartnet Unterstützung um DMX Lampen nutzen zu können\r\n| 1. Quartal 2013 | Build Scripts | Script um 3rd Party Repositories vor dem Build zu integrieren\r\n| 2. Quartal 2013 | Dokumentation | Strukturierte Webseite, Architekturschaubilder, Screenshots\r\n| 2. Quartal 2013 | SessionProxy | Authentifizierung für den Control Socket\r\n| 2. Quartal 2013 | Android App |  Modulare Plugin Unterstützung statt monolitischer Block\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}