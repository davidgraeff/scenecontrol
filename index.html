<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Scenecontrol - Ease your life</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
	<link rel="stylesheet" href="stylesheets/tipTip.css">
	<link rel="stylesheet" href="stylesheets/gh-fork-ribbon.css" />
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
	<!-- BEGIN JavaScript -->
	<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script>
    <script type="text/javascript" src="jquery.timeago.js"></script>
    <script type="text/javascript" src="github-latest-commits.js"></script>
	<script type="text/javascript" src="jquery.tipTip.minified.js"></script>
	<script type="text/javascript" src="code.js"></script>
  </head>
  <body>
	  <div class="github-fork-ribbon-wrapper right">
        <div class="github-fork-ribbon">
            <a href="https://github.com/simonwhitaker/github-fork-ribbon-css">Fork me on GitHub</a>
        </div>
    </div>
    <div class="wrapper">
      <header>
        <h1>SceneControl <a href="https://travis-ci.org/davidgraeff/scenecontrol"><img src="https://travis-ci.org/davidgraeff/scenecontrol.png?branch=master" alt="Build Status"></a></h1>

<p>Leicht zu bedienende Steuerungssoftware für eine einfach erweiterbare Heimautomatisierung.</p>

        <ul class="getit">
          <li><a href="https://github.com/davidgraeff/scenecontrol/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://launchpad.net/%7Edavid-graeff/+archive/scenecontrol">Packet für <strong>Ubuntu</strong></a></li>
          <li><a href="https://github.com/davidgraeff/scenecontrol">View On <strong>GitHub</strong></a></li>
        </ul>

		<div id="latest-commits-widget"  data-username="davidgraeff" data-repo="scenecontrol" data-limit="1">
			<div id="latest-commits-header">
				<div class="gh-ico"></div>
				<h4>Latest Commits</h4>
			</div>
			<ul id="commit-history"></ul>
		</div>

		<p style="margin-top:10px">
		<iframe src="http://ghbtns.com/github-btn.html?user=davidgraeff&repo=scenecontrol&type=watch&count=true"  allowtransparency="true" frameborder="0" scrolling="0" width="110" height="20"></iframe>
		</p>
      </header>

      <section>

      <h1>Steuerungssoftware für Heimautomatisierung</h1>
   <p>
		
	   SceneControl erfüllt Heimautomatisierungsaufgaben über eine robuste Prozess/Plugin Architektur. Ein <em>Always-ON</em> System wie z.B. der Rasberry PI wird vorausgesetzt.
		Über einen Editor im Webbrowser werden einfach Ereignisse, Bedingungen und Aktionen über Szenen verknüpft.
		Einige Plugins, sowie die Basisfunktionalität von SceneControl kann von einer Android App gesteuert werden. 
	</p>
	
<table>
	<tr><th>Anwendungsgebiete</th><th>Eigenschaften</th></tr>
	<tr><td>
		<ul>
		<li>Intelligenter Wecker</li>
		<li>Energiesparsystem</li>
		<li>Intelligenter Raum</li>
		<li>Automatisiertes Heimkino</li>
		</ul>
	</td><td>
		<ul>
		<li>Niedrige Ausfallrate durch Prozessarchitektur</li>
		<li>Effizientes C++ Backend</li>
		<li>Austauschbare Datenhaltung</li>
		<li>JSON Kommunikationsformat für einfach zu erstellende Frontends (HTML-Editor, Android APP)</li>
		</ul>
	</td></tr>
</table>

<h1>Prozess-Architektur</h1>
	<img src="images/Architektur2.png" style="" />
	<p>Der ausführende Kernprozess, im Schaubild mittig dargestellt, wird im weiteren SceneServer genannt. Dieser Kernprozess
	ist sehr minimalistisch konstruiert um die Fehleranfälligkeit zu minimieren. Die Datenhaltung läuft in diesem Prozesskontext,
	der <span class="tooltip" title="TCP-Socket, welcher JSON-Nachrichten annimmt">Kommando-Socket</span> und ein Thread-Pool für
	aktuell ausgeführte Szenen. Die eigentliche Funktionalität wird über Pluginprozesse bereitgestellt. In der Grafik sind diese
	um den Kernprozess herum skizziert. Pluginprozesse können untereinander kommunizieren (Abhängigkeitsverhältnis).

	<h3>Ladevorgang</h3>
		<p>Der SceneServer baut nach dem Start eine Verbindung zur <em>Datenhaltung</em> auf und fordert Plugin Konfigurationen an.
		Eine Plugin Konfiguration besteht aus genau den Parametern um eine neue Plugin Instanz zu starten. Eine Plugin
		Instanz ist ein eigenständiger Systemprozess. Stürzt ein solcher Prozess ab, etwa weil die Hardware nicht
		wie erwartet reagiert, hat das keine negativen Konsequenzen für den SceneServer.</p>

		<p>Aus der <em>Datenhaltung</em> werden anschließend alle Szenen angefordert und in ausführbare Objekte überführt.
		Alle auf diesen Szenen registrierten Ereignisse werden bei den zuständigen Plugin-Instanzen registriert.</p>

<h3>Ausführung</h3>
<p>Sobald ein registriertes Ereignis eintritt, wird der SceneServer kontaktiert und die mit dem Ereignis verbundene
Szene wird <span class="tooltip" title="Was mit Ausführung einer Szene gemeint ist, wird weiter unten erläutert.">ausgeführt</span>.
</p>

<p>Durch die Trennung in Prozesse mit fest gelegtem, eingegrenztem Aufgabenbereich ist die Ausfallsicherheit der
gesamten Architektur besonders hoch und für den 24/7 Betrieb ausgelegt.</p>

<h2>Steuerung über Kommando-Socket</h2>
<p>Über einen TCP Port i.d.R. Port 3101 können per JSON kodierte Nachrichten an den Prozess abgesetzt werden.
Der Server selber bietet dabei keine Session- oder Sicherheitsverwaltung.
Diese Funktionalitäten können mit zusätzlichen Proxy Prozessen abgedeckt werden.</p>

<img src="images/Architektur.png" style="" />

<h2>SessionProxy</h2>

<p>Der SessionProxy handelt mit dem SceneServer einen neuen Port für das JSON Kommandointerface aus und öffnet selber
den JSON Kommandointerface Port. Somit werden effektiv alle neuen Verbindungen über den SessionProxy ablaufen.
Alle Verbindungen erfordern ab dann eine Authentifizierung gegenüber den auf dem Betriebssystem vorhandenen Benutzern.
Zugriffsrechte werden durch Gruppenmitgliedschaften des angegeben Benutzers geregelt und müssen in der SessionProxy
Konfiguration gesondert angegeben werden.
Ein Beispiel: Ein Nutzer wählt über die Android App eine Szene zur Ausführung aus.
Der SessionProxy wird diese Ausführungsanfrage nur an den SceneServer weiterleiten, wenn der Nutzer sich als "{NUTZER}"
beim Start der Android App authorisiert hat.</p>

<h2>Websocketsproxy</h2>

<p>Über den Websocketsproxy können sich Webclients über das WebSocket Protokoll mit dem SceneServer verbinden
und das JSON Kommandointerface des SceneServers nutzen.</p>

<h2>Kommunikation: Plugin &lt;-&gt; Plugin &lt;-&gt; SceneServer</h2>

<p>Plugins sind als eigene Prozesse modelliert, welche selbstständig eine Kommunikationsverbindung zum Server aufbauen müssen.
Da viele Qt Container und Basisklassen serialisiert werden können, wird ein einfaches QDataStream basiertes Protokoll für
die Kommunikation zwischen Plugin Prozess und SceneServer verwendet. Unter Windows werden NamedPipes, unter Linux/MacOS
UnixSockets verwendet.
Plugins können Eigenschaften (properties) besitzen und auf Eigenschaftsänderungen des Servers oder anderer Plugins
reagieren. Für C++ Plugins gibt es ein PluginInterface, welches zu implementieren ist. Theoretisch können auch andere
Programmiersprachen für Plugins verwendet werden.</p>

<h2>Datenhaltung</h2>

<p>Ereignisse, Bedingungen, Aktionen und Szenen werden als JSON Objekte direkt auf dem Dateisystem hinterlegt. Die
Datenspeicherung ist durch eine eigene Bibliothek gekapselt um einen leichten Austausch durch andere Technologien zu ermöglichen.
Die Speicherung auf dem Dateisystem bietet jedoch bereits das Erfassen von Änderungen der Daten durch
Drittanwendungen sowie die Nutzung üblicher Dateiverwaltungswerkzeuge. Manuelles Replizieren sowie
regelmäßige Sicherungen können auf Dateiebene genutzt werden (Dropbox, github, ...).</p>

<h2>Szenen</h2>

<p>Eine Szene definiert sich durch einen Namen, gfs. zugewiesene Kategorien und Szenenelementen.
Szenenelemente sind Ereignisse, Bedingungen und Aktionen, welche als gerichteter Graph organisiert sind.
Ein Graph enthält Knoten und Kanten, welche die Knoten verbinden. Übertragen auf eine Szene
sind dadurch i.d.R. Ereignisse über Kanten mit Bedingungen verknüpft, welche wiederum mit
Aktionen verbunden sind. Eine solche Kette von Szenenelementen heißt hier <em>Ereigniskette</em>.</p>
	
<p>Eine Ereigniskette kann Verzweigungen besitzen, also von einem Element kann diese zu zwei oder mehr Elementen
weiterführen. Eine Szene kann mehrere Ereignisketten enthalten. Weiter oben wurde festgestellt,
dass eine Szene bei Eintritt eines seiner Ereignisse ausgeführt wird. Tatsächlich wird aber
nur die Ereigniskette ab dem Punkt abgearbeitet, wo sich dieses Ereignis befindet.</p>

<p>Ein Beispiel: Ein Ereignis kann das Eintreten eines gewissen Zeitpunktes sein,
eine daran angebundene Bedingung könnte einen Steckdosenzustand prüfen,
eine darauf folgende Aktion löst etwa das Ändern der Lichwerte von Leuchtdioden aus.</p>


<h1>Grafisches Programm zur Verwaltung von Szenen:</h1>

<p>Um Ereignisse, Bedingungen und Aktionen in Szenen grafisch zu gestalten befindet
sich eine Webbrowser Anwendung im Ordner "htmleditor".
Der SceneServer und der WebSocketProxy müssen laufen.</p>

   <img src="images/editor-feb-2013.jpg" style="margin-bottom:10px" />

<h1>Mitgelieferte Plugins</h1>

		<table>
		<tr>
		<th>Name</th>
		<th>Typ</th>
		<th>Beschreibung</th>
		</tr>
		<tr>
		<td>Leds</td>
		<td>Generisch</td>
		<td>Generisches Leuchtdioden Plugin zur Verwaltung aller angemeldeten Leuchtdioden.</td>
		</tr>
		<tr>
		<td>Schalter</td>
		<td>Generisch</td>
		<td>Generisches Schalter Plugin zur Verwaltung aller angemeldeten Schalter.</td>
		</tr>
		<tr>
		<td>Time</td>
		<td>Generisch</td>
		<td>Bietet feste und periodische Zeitereignisse an.</td>
		</tr>
		<tr>
		<td>WOL</td>
		<td>Generisch</td>
		<td>Wakeup on lan. Ermöglicht das starten eines über die angegebene MAC festgelegten PCs.</td>
		</tr>
		<tr>
		<td>DMX/ArtNet</td>
		<td>Hardware</td>
		<td>Erlaubt die Steuerung von konfigurierten DMX Lampen über das Leds Plugin. Verwendet ArtNet, also ist eine Hardware Umsetzung IP--&gt;DMX notwendig.</td>
		</tr>
		<tr>
		<td>Linux Input Events</td>
		<td>OS Abhängig</td>
		<td>Tastenereignisse vom Linux Input Framework (etwa usb Fernbedienungen, Tastaturen).</td>
		</tr>
		<tr>
		<td>MPD</td>
		<td>Softwarespezifisch</td>
		<td>Steuert den Music Player Daemon.</td>
		</tr>
		<tr>
		<td>XBMC</td>
		<td>Softwarespezifisch</td>
		<td> Steuert das XBox Media Center.</td>
		</tr>
		<tr>
		<td>Pulseaudio</td>
		<td>Softwarespezifisch</td>
		<td>Steuert Lautstärkekanäle des Pulseaudio daemons.</td>
		</tr>
		</table>

<h1>Software bauen</h1>

<p>Es wird CMake (<a href="http://www.cmake.org">www.cmake.org</a>) benötigt. Im CMake-Gui Programm kann grafisch
der Quellcodeordner und ein davon unabhängiger BUILD-Ordner angegeben werden.
CMake versucht alle benötigten Abhängigkeiten und den angegebenen C++ Compiler
zu finden. Im nachfolgendem Abschnitt sind die Abhängigkeiten noch einmal
aufgeführt. Nach dem Generierungsschritt liegen (je nach Auswahl) Visual Studio
Projektdateien, Makefiles, usw vor.</p>

<p>Unter Windows: Hier wird VisualStudio 10+ empfohlen. Auf der Konsole kann nmake
verwendet werden, ansonsten lässt sich das Projekt auch mit der VS IDE bauen.</p>

<p>Unter Linux: Hier bietet sich das Erstellen lassen von Makefiles an. Anschließend
in den BUILD-Ordner wechseln und den Befehl "make" ausführen. Um ein Deb Packet
generieren zu lassen den Befehl "make package" nutzen.</p>

	<h2>Abhängigkeiten</h2>

		<table>
		<tr>
		<th>Name</th>
		<th align="center">Ubuntu Paket</th>
		<th align="right">Beschreibung</th>
		<th>Komponenten</th>
		</tr>
		<tr>
		<td>Qt4</td>
		<td align="center">libqt4-dev</td>
		<td align="right">Qt4 Framework</td>
		<td>Kernprozess</td>
		</tr>
		<tr>
		<td>SSL</td>
		<td align="center">libssl-dev</td>
		<td align="right">Sichere Verbindung</td>
		<td>Kernprozess, Kontrollsocket</td>
		</tr>
		<tr>
		<td>PAM</td>
		<td align="center">libpam0g-dev</td>
		<td align="right">Benutzerauthentifizierung</td>
		<td>SessionProxy</td>
		</tr>
		<tr>
		<td>Pulseaudio</td>
		<td align="center">libpulse-dev</td>
		<td align="right">Pulseaudio</td>
		<td>Plugin: Pulseaudio</td>
		</tr>
		<tr>
		<td>UDEV</td>
		<td align="center">libudev-dev</td>
		<td align="right">Linux Input Events</td>
		<td>Plugin: Linux_input_events</td>
		</tr>
		</table>

	<h2>Weiterentwicklung:</h2>

			<table>
			<tr>
			<th>Zeitraum</th>
			<th>Komponente</th>
			<th>Beschreibung</th>
			</tr>
			<tr>
			<td>1. Quartal 2013</td>
			<td>Plugin: dmx/artnet</td>
			<td>libartnet Unterstützung um DMX Lampen nutzen zu können</td>
			</tr>
			<tr>
			<td>1. Quartal 2013</td>
			<td>Build Scripts</td>
			<td>Script um 3rd Party Repositories vor dem Build zu integrieren</td>
			</tr>
			<tr>
			<td>1. Quartal 2013</td>
			<td>Build Scripts</td>
			<td>Ubuntu PPA Build einrichten</td>
			</tr>
			<tr>
			<td>2. Quartal 2013</td>
			<td>Dokumentation</td>
			<td>Strukturierte Webseite, Anleitungen, Architekturschaubilder, Screenshots</td>
			</tr>
			<tr>
			<td>2. Quartal 2013</td>
			<td>SessionProxy</td>
			<td>Authentifizierung für den Control Socket</td>
			</tr>
			<tr>
			<td>2. Quartal 2013</td>
			<td>Android App</td>
			<td>Modulare Plugin Unterstützung statt monolitischer Block</td>
			</tr>
			</table>
      </section>
      <footer>
		  <p>This project is maintained by <a href="https://github.com/davidgraeff">David Gräff</a><br/><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>